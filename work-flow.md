# 软件工程相关基本概念和流程

最后老师的[课程PPT总结](https://github.com/luzhixing12345/WHU-software-engineering/releases/download/v0.0.1/SE_summarize.pdf)非常好,很全面系统,务必细看

> 这部分可能会出现论述题,或者是老师一高兴来一个开放题,来吧,谈谈软件工程这门课学到了啥,你总的有东西写是吧

## 软件危机(至今还没有被解决)

两个方面的问题

- 如何开发软件以满足用户对软件日益增长的需求
- 如何维护数量不断膨胀的已有软件

**产生的原因(具体)**

- 软件本身的特点

  - 产品与开发过程缺乏可见性：中间结果质量难以衡量,风险大
  - 单品生产：开发周期长,进度难控制,成本高
  - 产品的逻辑性：不易修改,修改往往会涉及需求、设计等各阶段
  - 对人的强依赖性：需求难获取,各阶段工作质量因人而异
  - 规模庞大带来的复杂性：必须任务分解、团队合作完成

- 软件开发和维护的不正确方法

  - 忽视软件需求分析的重要性  **软件=代码+文档+数据**
  - 误以为软件开发就是写程序并使之运行 团队合作的工程化项目
  - 轻视软件维护 很重要,需要方法+工具

软件开发的变化是

- 需求越来越复杂
- 规模越来越大
- 背景环境易变（用户、环境、硬件、应用需求）

如果说现在有比现有编码技术快10%的新的编码技术,是否采用?

软件工程角度来说需要考虑很多因素

- 要考虑培训费用
- 考虑将新技术引入开发组织中的花费
- 考虑引入后的维护问题
- ...

## 软件工程的产生

由于软件危机的出现,我们需要寻找克服的方法

- 建立正确认识

  - 软件=代码+文档+数据
  - 软件开发是组织良好、管理严密、各类人员协同配合、共同完成的工程项目

- 推广使用软件开发的工程化方法和技术
- 开发和使用好的工具软件

软件危机只是表现结果,不是问题产生的根本原因。**工程化根本原因**是需求多样、规模增大带来的求解复杂性——超出了人们通常问题求解的能力

![20220608144851](https://raw.githubusercontent.com/learner-lu/picbed/master/20220608144851.png)

可以看到编码实现只是软件工程中很小的一部分

软件工程注重: **工具,方法,过程**, 编码并不在其中

## 软件生命周期（Software Development LifeCycle）是指软件的产生直到成熟的全部过程

> 关于软件**过程**中的模型参考[软件模型](model.md)

可以分为以下六个阶段

1. 需求阶段
   1. 抽取概念
   2. 提取客户需求
2. 分析阶段
   1. 分析客户需求
   2. 撰写规格说明文档
3. 设计阶段
   1. 结构设计
   2. 详细设计
4. 实现阶段
   1. 编码
   2. 单元测试
   3. 集成
   4. 验收测试
5. 交付后维护
   1. 纠错性维护
   2. 完善性维护
   3. 适应性维护
6. 退役

## 结构化方法和面向对象方法(OO方法)

结构化方法也是传统的方法:

- 自顶向下
- 逐步求精
- 模块化设计

OO方法 : 通过增强软件的可扩充性和可复用性来改善开发人员的生产活动,从而控制软件维护的复杂性和费用

各有特点: 不存在方法的先进与过时

成功开发软件系统的前提有正确清晰的界定需求

根据问题的特点选择合适的方法: 应关注方法的成本和收获的价值

## 建模工具

建模工具主要用于处理 需求/分析/设计三个方面的问题

值得一提的是,这一部分的文字描述认真写一下,车轱辘话来回说转换转换就行

### 需求模型

- 需求陈述
- 用例图+用例描述

> 这里解释一下,需求陈述就是给了问题的文字描述,从中提取一下关键信息,用语言转义一下,把重点内容提炼一下
>
> 用例图和用例描述见[用例模型](Use-Case-model.md) **这一部分不需要写场景描述**

### 分析模型

分析模型分为三个部分,功能模型 + 数据模型 (对象模型) + 控制模型

**结构化方法和面向对象方法在建模时是两套方法,注意区分**

#### 功能模型

- 结构化方法: 数据流图+数据字典
  
  (数据字典没提到就不写,这个写起来巨麻烦,问了老师反正没反对)

- 面向对象方法: 用例图+用例描述+场景描述

  这里的场景描述一定要有正常场景和异常场景,**切记**

#### 数据模型/对象模型

> 对于结构化来说时数据模型,对于OO是对象模型

- 结构化方法: 实体-联系图(ER图)
- 面向对象方法: 类图

#### 控制模型

状态转换图

> 两种方法没有区别,都是画这个

### 设计模型

软件层次图 / 类图 + 盒图、PAD图、流程图、伪代码

> 这一部分怎么说呢,大概知道怎么画吧,不用全画,但是总是要准备的是吧
>
> 参考[设计模型各种图](graph.md)

## 测试活动

整个流程中没有测试阶段,因为在软件产品准备好交付给客户时才检查它,实在是太晚了,在每个阶段接近结束的时候测试（太晚了,在整个项目结束时测试（更加来不及了

将测试活动贯穿于整个软件生命周期中,测试职责归属于每一个软件从业者,以及软件质量保证小组

测试分为如下几个步骤

![20220608151043](https://raw.githubusercontent.com/learner-lu/picbed/master/20220608151043.png)

注意: 测试是针对**需求阶段**进行的,一定是你的需求的预期结果和你的程序的执行结果不相同,才是说明软件存在问题

测试分为黑盒测试和白盒测试,参考[测试](test.md)

## 文档

同样也没有文档阶段,软件产品开发完准备交付给客户时再写文档,那就太晚了,因为

- 关键人员可能在文档完成前离开
- 如果没有前一阶段的文档,就没办法实施下一阶段
- 没有文档也没办法测试
- 没有文档就无法实施维护

文档活动应当伴随着构建软件产品的所有其他开发和维护活动进行,没有单独的文档阶段

## 关于维护

传统维护的定义比较模糊, 在软件产品安装之后一天发现并纠正一个错误 和 同样的错误是在软件安装之前一天发现并纠正哪个是维护,以及软件产品已经被安装后客户想要增加该软件产品的功能 和 客户想要在软件产品安装之前做相同的变化,是**维护**还是**开发**并不好界定

新的定义是: **是“软件因存在问题或因有改进或适应性需求时,对代码及相应文档所进行修改”的过程**,无论何时,只要软件被修改,就是维护,无论修改是发生在软件产品安装之前还是安装之后

## 传统范型中的计划活动

- 在项目的开始,对需求和分析阶段进行初步计划
- 当用户签署了规格说明后就可以制定出软件项目管理计划(SPMP)
- 在后续项目实施过程中,管理者要监督SPMP的执行情况

计划活动贯穿于软件生命周期的始终,不存在独立的计划阶段

## 软件开发的实质

问题的认识和表达,掌握软件开发的本质才是最重要的,认识 理解 表达需求, 从用户论域开始,最终到计算机语言表示
